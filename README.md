# DEMO
Отлично! Давайте разберем этот код простым языком для новичка.

## Что это за программа?

Это **CRUD-приложение** - программа для работы с базой данных. CRUD означает:
- **C**reate (Создать) - добавлять новые записи
- **R**ead (Читать) - просматривать данные  
- **U**pdate (Обновить) - редактировать записи
- **D**elete (Удалить) - удалять записи

## Какие технологии используем?

### 1. **Tkinter** - для создания окон и кнопок
```python
import tkinter
from tkinter import ttk, messagebox
```
- `tkinter` - стандартная библиотека Python для создания графического интерфейса
- `ttk` - более современные виджеты (красивые таблицы)
- `messagebox` - всплывающие окна с сообщениями

### 2. **SQLite** - для хранения данных
```python
import sqlite3
```
- Легкая база данных, которая хранится в одном файле
- Не требует установки сервера

## Как устроена программа?

### Главный класс `MainApp`
Это "мозг" программы, который управляет всем:

```python
class MainApp:
    def __init__(self):
        # Создаем окно
        # Подключаемся к базе данных
        # Настраиваем интерфейс
```

### Основные части программы:

## 1. **Создание окна** (`__init__` и `setup_ui`)
```python
self.root = tkinter.Tk()  # Создаем главное окно
self.root.title("Главная БД")  # Заголовок окна
self.root.geometry("900x600")  # Размер окна
```

**Что создается в интерфейсе:**
- Кнопки для переключения между таблицами
- Кнопки для добавления/удаления/редактирования
- Поле для поиска
- Таблица для отображения данных

## 2. **Работа с базой данных** (`create_db`)
```python
self.conn = sqlite3.connect('main_db.db')  # Подключение к БД
```

**Создаем 4 таблицы:**
- `users` - пользователи (логин, роль)
- `categories` - категории товаров
- `items` - товары (название, цена, статус)
- `operations` - операции с товарами

## 3. **Отображение данных** (`load_data`)
```python
self.tree = ttk.Treeview()  # Создаем таблицу
```
Treeview - это виджет, который показывает данные в виде таблицы с колонками

## Основные методы и их работа:

### **Методы для работы с данными:**

#### `load_data()` - Загружает данные в таблицу
```python
for row in self.conn.execute(config['query']):  # Выполняем SQL запрос
    self.tree.insert('', tkinter.END, values=row)  # Добавляем строку в таблицу
```

#### `add_record()` - Добавляет новую запись
1. Открывает форму для ввода данных
2. Получает данные от пользователя
3. Выполняет SQL команду `INSERT`
4. Обновляет таблицу

#### `delete_record()` - Удаляет запись
1. Получает выбранную строку
2. Спрашивает подтверждение
3. Выполняет SQL команду `DELETE`

#### `edit_record()` - Редактирует запись
1. Получает текущие данные
2. Открывает форму с заполненными полями
3. Выполняет SQL команду `UPDATE`

### **Методы для удобства:**

#### `sort_by_column()` - Сортировка по колонке
```python
def sort_key(x):
    val = x[0]
    if str(val).replace('.', '').replace('-', '').isdigit():
        return (0, float(val))  # Числа
    return (1, str(val).lower())  # Текст
```
Умно определяет тип данных и сортирует правильно!

#### `search()` - Поиск по таблице
```python
sql = f"{config['query']} WHERE {search_field} LIKE ?"
# LIKE с % - это SQL способ поиска части текста
```

#### `center_window()` - Центрирует окно на экране
```python
x = (window.winfo_screenwidth() // 2) - (width // 2)
y = (window.winfo_screenheight() // 2) - (height // 2)
```

## Ключевые концепции для новичка:

### 1. **Конфигурация таблиц**
```python
self.table_config = {
    'users': {
        'columns': ['ID', 'Логин', 'Роль'],  # Что показывать
        'fields': ['username', 'role'],       # Поля в БД
        'search_field': 'username'            # По чему искать
    }
}
```
Это "настройки" для каждой таблицы - какие колонки показывать, как называются поля в БД.

### 2. **SQL запросы**
- `SELECT * FROM users` - получить все данные
- `INSERT INTO users (username, role) VALUES (?, ?)` - добавить запись
- `UPDATE users SET username=? WHERE id=?` - обновить запись
- `DELETE FROM users WHERE id=?` - удалить запись

### 3. **Обработка событий**
```python
command=lambda t=table: self.switch_table(t)  # При нажатии кнопки
self.search_var.trace('w', lambda *args: self.search())  # При вводе текста
```

### 4. **Модальные окна**
`create_form()` создает отдельное окно для ввода данных:
```python
window = tkinter.Toplevel(self.root)  # Дочернее окно
window.grab_set()  # Блокируем главное окно
```

## Как все работает вместе:

1. **Запуск:** Создается БД, интерфейс, загружаются данные
2. **Пользователь:** Выбирает таблицу → данные загружаются
3. **Добавление:** Кнопка "Добавить" → форма → сохранение в БД → обновление таблицы
4. **Поиск:** Ввод текста → фильтрация данных в реальном времени
5. **Сортировка:** Клик по заголовку → данные пересортировываются

Это отличный пример того, как связать базу данных с графическим интерфейсом!

Нет, я не рассказал про все! Давайте дополним важными деталями:

## Что я пропустил:

### **1. Обработка ошибок**
```python
try:
    self.conn.execute(sql, data)
    self.conn.commit()
except Exception as e:
    messagebox.showerror("Ошибка", f"Не удалось добавить запись: {e}")
```
**Что это значит:**
- `try-except` - ловим ошибки, чтобы программа не падала
- `commit()` - подтверждаем изменения в БД (без этого данные не сохранятся!)

### **2. Внешние ключи (Foreign Keys)**
```python
FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE RESTRICT
```
**Это важно!** Означает:
- Товар должен принадлежать существующей категории
- Нельзя удалить категорию, если есть товары
- `RESTRICT` - запрещает удаление при наличии связей

### **3. Переменные состояния**
```python
self.current_table = 'users'  # Какая таблица сейчас активна
self.sort_reverse = {}        # Направление сортировки для каждой колонки
self.search_var = tkinter.StringVar()  # Связана с полем поиска
```

### **4. Lambda функции**
```python
command=lambda t=table: self.switch_table(t)
```
**Зачем нужно:** В цикле все кнопки получили бы одинаковое значение `table`. Lambda "замораживает" значение.

### **5. Автоматическое обновление поиска**
```python
self.search_var.trace('w', lambda *args: self.search())
```
**`trace('w')`** - отслеживает изменения в поле ввода. Поиск происходит при каждом символе!

### **6. Работа с TreeView**
```python
selected = self.tree.selection()  # Получить выбранные строки
values = self.tree.item(selected[0])['values']  # Данные строки
self.tree.move(item, '', i)  # Переместить строку (для сортировки)
```

### **7. Модальность окон**
```python
window.transient(self.root)  # Окно привязано к главному
window.grab_set()           # Блокирует главное окно
window.wait_window()        # Ждет закрытия окна
```

### **8. Типы данных и их обработка**
```python
def sort_key(x):
    val = x[0]
    if str(val).replace('.', '').replace('-', '').isdigit():
        return (0, float(val))  # Числа сортируются как числа
    return (1, str(val).lower())  # Текст - без учета регистра
```

### **9. SQL инъекции и безопасность**
```python
# ПРАВИЛЬНО - используем параметры:
self.conn.execute("SELECT * FROM users WHERE username = ?", (username,))

# НЕПРАВИЛЬНО - уязвимо для SQL инъекций:
# self.conn.execute(f"SELECT * FROM users WHERE username = '{username}'")
```

### **10. Жизненный цикл приложения**
```python
def run(self):
    self.root.mainloop()  # Запуск главного цикла событий
    self.conn.close()     # Закрытие БД при выходе
```

### **11. Тестовые данные**
```python
c.execute("SELECT COUNT(*) FROM categories")
if c.fetchone()[0] == 0:  # Если БД пустая
    # Добавляем тестовые данные
```

### **12. Динамическое создание SQL**
```python
fields_str = ','.join(config['fields'])  # "username,role"
placeholders = ','.join(['?' for _ in data])  # "?,?"
sql = f"INSERT INTO {self.current_table} ({fields_str}) VALUES ({placeholders})"
```

### **13. Конфигурационный подход**
Вместо хардкода для каждой таблицы - используется общая конфигурация. Чтобы добавить новую таблицу, нужно только дополнить `table_config`.

### **14. Центрирование окон**
```python
window.update_idletasks()  # Обновляем размеры до расчета позиции
```

## Архитектурные принципы:

1. **Разделение ответственности** - каждый метод делает одну вещь
2. **Конфигурационный подход** - легко добавлять новые таблицы
3. **Обработка ошибок** - программа не падает при проблемах
4. **Пользовательский опыт** - подтверждения, центрирование окон, автопоиск

Теперь картина полная! 😊
